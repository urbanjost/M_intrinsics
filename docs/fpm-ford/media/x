NAME
   prep(1) - [DEVELOPER] preprocess FORTRAN source files
   (LICENSE:MIT)

SYNOPSIS
   prep [[-D] define_list]
        [-I include_directories]
        [-i input_file(s)]
        [-o output_file]
        [--system]
        [--type FILE_TYPE | --start START_STRING --stop STOP_STRING]
        [--prefix character|ADE]
        [--keeptabs]
        [--noenv]
        [--width n]
        [-d ignore|remove|blank]
        [--comment default|doxygen|ford|none]
        [--ident]
        [--verbose]
        [--version]
        [--help]
DESCRIPTION

   A preprocessor performs operations on input files before they are passed to
   a compiler, including conditional selection of lines based on directives
   contained in the file. This makes it possible to use a single source file
   even when different code is required for different execution environments.

   The prep(1) preprocessor has additional features that allow documentation
   in the same file as the source and the generation of generic code using a
   simple templating technique. The basic directives ....

   * Conditionally output parts of the source file (controlled by expressions
     on the directives $IF, $IFDEF, $IFNDEF, and $ENDIF. The expressions may
     include variables defined on the command line or via the directives
     $DEFINE, and $UNDEFINE).

   * Include other files (provided by directive $INCLUDE).

   * Define parcels of text that may be replayed multiple times with
     expansion, allowing for basic templating (controlled by directives
     $PARCEL/$ENDPARCEL and $POST). The mechanism supported is to replace
     text of the form ${NAME} with user-supplied strings similar to the
     POSIX shell (controlled by directives $SET and $IMPORT).

   * Filter blocks of text and convert them to comments, a CHARACTER array,
     Fortran WRITE statements, ... (provided by the $BLOCK directive.)

     The blocks of text may also be written to a file and executed, with
     stdout captured and included in the prep(1) output file.

     Blocked text may optionally be simultaneously written to a separate file,
     typically for use as documentation.

   * Call system commands (using the $SYSTEM directive).

   * Generate multiple output files from a single input file (using $OUTPUT).

   * Record the parameters used and the date and time executed as Fortran
     comments in the output (using $SHOW).

   * Cause an error (controlled by directive $STOP or $ERROR) and produce
     messages on stderr (using $MESSAGE).

OPTIONS
   define_list, -D define_list  An optional space-delimited list of expressions
                                used to define variables before file processing
                                commences.

   -i input_files               The default input file is stdin. Filenames are
                                space-delimited. In a list, @ represents stdin.

   The suggested suffix for Fortran input files is ".ff" for code files unless
   they contain $SYSTEM directives in which case ".FF" is preferred. $INCLUDE
   files should use ".ffinc" and ".FFINC" if they include prep(1) directives.
   This naming convention is not required.

   Files may also end in supported suffixes such as ".md", as explained under
   the --type option description.

   -o output_file               The default output file is stdout.

   -I include_directories  The directories to search for files specified on
                           $INCLUDE directives.

   --system         Allow system commands on $SYSTEM directives to be executed.

   --type FILETYPE  This flag indicates to skip input lines until after a
                    specific start string is encountered and to stop once a
                    specific end string is found, left-justified on lines by
                    themselves.

                        FileType  Start_String            Stop_String
                        --------  ------------            -----------
                        md        ```fortran              ```
                        html      <xmp>                   </xmp>
                        tex       \begin{minted}{Fortran} \end{minted}
                        auto
                        none

                    The default type is "auto", in which case files will be
                    processed according to their file suffix.

                    This allows for easily extracting code from common document
                    formats. This is particularly useful with extended markdown
                    formats, allowing for code source to be easily documented
                    and for tests in documents to be able to be extracted and
                    tested. "auto" switches processing mode depending on input
                    file suffix, treating supported file suffixes
                    ("md","html","tex") appropriately.

   --start STRING   Same as --type except along with --stop allows for custom
                    strings to be specified.

   --stop STRING    Same as --type except along with --start allows for custom
                    strings to be specified.

   --comment        Try to style comments generated in $BLOCK COMMENT blocks
                    for other utilities such as doxygen. Default is to
                    prefix lines with '! '. Allowed keywords are
                    currently "default", "doxygen","none","ford".
                    THIS IS AN ALPHA FEATURE AND NOT FULLY IMPLEMENTED.

   --prefix ADE|letter  The directive prefix character. The default is "$".
                        If the value is numeric it is assumed to be an ASCII
                        Decimal Equivalent (Common values are 37=% 42=* 35=#
                        36=$ 64=@).

   --noenv          The $IFDEF and $IFNDEF directives test for an internal
                    prep(1) variable and then an environment variable by
                    default. This option turns off testing for environment
                    variables.

   --keeptabs       By default tab characters are expanded assuming a stop has
                    been set every eight columns; and trailing carriage-return
                    are removed. Use this flag to prevent this processing from
                    from occurring.

   --ident          The output of the $IDENT directive is in the form of a
                    comment by default. If this flag is set the output is
                    of the form described in the $IDENT documentation
                    so executables and object code can contain the metadata
                    for use with the what(1) command. Note this generates an
                    unused variable which some compilers might optimize
                    away depending on what compilation options are used.

   -d ignore|remove|blank  Enable special treatment for lines beginning
                           with "d" or "D". The letter will be left as-is
                           (the default); removed; or replaced with a blank
                           character. This non-standard syntax has been
                           used to support the optional compilation of
                           "debug" code by many Fortran compilers when
                           compiling fixed-format Fortran source.

   --width n   Maximum line length of the output file. The default is 1024.
               The parameter is typically used to trim fixed-format FORTRAN
               code that contains comments or "ident" labels past column 72
               when compiling fixed-format Fortran code.

   --verbose   All commands on a $SYSTEM directive are echoed to stderr with a
               "+" prefix. Text following the string "@(#)" is printed to stderr
               similar to the Unix command what(1) but is otherwise treated as
               other text input. Additional descriptive messages are produced.

   --version   Display version and exit

   --help      Display documentation and exit.

INPUT FILE SYNTAX

   The prep(1) preprocessor directives begin with "$" (by default) in column
   one, and prep(1) will output no such lines. Other input is conditionally
   written to the output file(s) based on the case-insensitive command names.

   An exclamation character FOLLOWED BY A SPACE on most directives
   begins an in-line comment that is terminated by an end-of-line. The space
   is required so comments are not confused with C-style logical operators such
   as "!", which may NOT be followed by a space.

 VARIABLES AND EXPRESSIONS

   INTEGER or LOGICAL expressions are used to conditionally select
   output lines. An expression is composed of INTEGER and LOGICAL
   constants, variable names, and operators. Operators are processed
   as in Fortran and/or C expressions. The supported operators are ...

       #-----#-----#-----#-----#-----#                #-----#-----#
       |  +  |  -  |  *  |  /  |  ** | Math Operators #  (  |  )  | Grouping
       #-----#-----#-----#-----#-----#                #-----#-----#
       Logical Operators
       #-----#-----#-----#-----#-----#-----#-----#-----#-----#-----#------#
       | .EQ.| .NE.| .GE.| .GT.| .LE.| .LT.|.NOT.|.AND.| .OR.|.EQV.|.NEQV.|
       |  == |  /= |  >= |  >  |  <= |  <  |  !  |  && |  || | ==  |  !=  |
       #-----#  != #-----#-----#-----#-----#-----#-----#-----#-----#------#
             #-----#
       C-style operators NOT supported:   %,  <<,  >>, &,  ~

DIRECTIVES

 The directives fall into the following categories:

 VARIABLE DEFINITION FOR CONDITIONALS
   Directives for defining variables ...

      $DEFINE   variable_name[=expression] [;...]          [! comment ]
      $UNDEFINE|$UNDEF variable_name [;...]                [! comment ]

   Details ...

      $DEFINE variable_name [=expression]; ... [! comment ]

   Defines a numeric or logical variable name and its value. The variable
   names may subsequently be used in the expressions on the conditional output
   selector directives $IF, $ELSEIF, $IFDEF, and $IFNDEF.

   If the result of the expression is ".TRUE." or ".FALSE." then the variable
   will be of type LOGICAL, otherwise the variable is of type INTEGER (and the
   expression must be an INTEGER expression or null). If no value is supplied
   the variable is given the INTEGER value "1".

   Variables are defined from the point they are declared in a $DEFINE
   directive or the command line until program termination unless explicitly
   undefined with a $UNDEFINE directive.

   Example:

    > $define A                        ! will have default value of "1"
    > $define B = 10 - 2 * 2**3 / 3    ! integer expressions
    > $define C=1+1; D=(-40)/(-10)
    > $define bigd= d .ge. a; bigb = ( (b >= c) && (b > 0) )  ! logical
    > $if ( A + B ) / C .eq. 1
    >    (a+b)/c is one
    > $endif
   Note expressions are not case-sensitive.

       $UNDEFINE variable_name[; ...]

   A symbol defined with $DEFINE can be removed with the $UNDEFINE directive.
   Multiple names may be specified, preferably separated by semi-colons.

   Basic globbing is supported, where "*" represents any string, and "?"
   represents any single character.

       DEFINED(variable_name[,...])

   A special function called DEFINED() may appear only in a $IF or $ELSEIF.
   If "variable_name" has been defined at that point in the source code,
   then the function value is ".TRUE.", otherwise it is ".FALSE.". A name is
   defined only if it has appeared in the source previously in a $DEFINE
   directive or been declared on the command line.
   The names used in compiler directives are district from names in the
   FORTRAN source, which means that "a" in a $DEFINE and "a" in a FORTRAN
   source statement are totally unrelated.
   The DEFINED() variable is NOT valid in a $DEFINE directive.

   Example:

    >        Program test
    > $IF .NOT. DEFINED (inc)
    >        INCLUDE "comm.inc"
    > $ELSE
    >        INCLUDE "comm2.inc"
    > $ENDIF
    >        END

   The file, "comm.inc" will be included in the source if the variable
   "inc", has not been previously defined, while INCLUDE "comm2.inc" will
   be included in the source if "inc" has been defined.

   Predefined variables are

    SYSTEMON = .TRUE. if --system was present on the command line, else .FALSE.

    UNKNOWN = 0 LINUX   = 1 MACOS   = 2 WINDOWS = 3
    CYGWIN  = 4 SOLARIS = 5 FREEBSD = 6 OPENBSD = 7
    In addition OS is set to what the program guesses the system type is.

     > $if OS == LINUX
     >    write(*,*)"System type is Linux"
     > $elseif OS == WINDOWS
     >    write(*,*)"System type is MSWindows"
     > $else
     >    write(*,*)"System type is unknown"
     > $endif

 CONDITIONAL CODE SELECTION
   directives for conditionally selecting input lines ...

       $IF  logical_integer-based expression |
       $IFDEF [variable_name|environment_variable] |
       $IFNDEF [variable_name|environment_variable]         [! comment ]
               { sequence of source statements}
       [$ELSEIF|$ELIF logical_integer-based expression      [! comment ]
               { sequence of source statements}]
       [$ELSE                                               [! comment ]
               { sequence of source statements}]
       $ENDIF                                               [! comment ]

   Details ...

       $IF/$ELSEIF/$ELSE/$ENDIF directives ...

   Each of these control lines delineates a block of source lines. If the
   expression following the $IF is ".TRUE.", then the following lines of
   source following are output. If it is ".FALSE.", and an $ELSEIF
   follows, the expression is evaluated and treated the same as the $IF. If
   the $IF and all $ELSEIF expressions are ".FALSE.", then the lines of
   source following the optional $ELSE are output. A matching $ENDIF ends the
   conditional block.

       $IFDEF/$IFNDEF directives ...

   $IFDEF and $IFNDEF are special forms of the $IF directive that simply test
   if a variable name is defined or not.

   The expressions may optionally be enclosed in parenthesis and followed by
   the keyword "THEN", ie. they may use Fortran syntax. For example, the
   previous example may also be written as:

     > $IF(OS .EQ. LINUX)THEN
     >    write(*,*)"System type is Linux"
     > $ELSEIF(OS .EQ. WINDOWS)THEN
     >    write(*,*)"System type is MSWindows"
     > $ELSE
     >    write(*,*)"System type is unknown"
     > $ENDIF

   Essentially, these are equivalent:

       $IFDEF varname  ==> $IF DEFINED(varname)
       $IFNDEF varname ==> $IF .NOT. DEFINED(varname)

   except that environment variables are tested as well by $IFDEF and $IFNDEF
   if the --noenv option is not specified, but never by the function DEFINED(),
   allowing for environment variables to be selectively used or ignored.
   The --noenv switch is therefore only needed for compatibility with fpp(1).
   For the purposes of prep(1) an environment variable is defined if it is
   returned by the system and has a non-blank value.

 MACRO STRING EXPANSION AND TEXT REPLAY
   Directives for defining replayable text blocks ...

       $PARCEL [blockname] / $ENDPARCEL                     [! comment ]
       $POST     blockname                                  [! comment ]
       $SET varname  string
       $IMPORT   envname[;...]                              [! comment ]

   Details ...

       $PARCEL [blockname] / $ENDPARCEL                     [! comment ]

   The block of lines between a "$PARCEL name" and "$ENDPARCEL" directive are
   written to a scratch file WITHOUT expanding directives. the scratch file can
   then be read in with the $POST directive much like a named file can be with
   $INCLUDE except the file is automatically deleted at program termination.

       $POST     blockname                                  [! comment ]

   Read in a scratch file created by the $PARCEL directive. Combined with
   $SET and $IMPORT directives this allows you to replay a section of input
   and replace strings as a simple templating technique, or to repeat lines
   like copyright information or definitions of (obsolescent) Fortran COMMON
   blocks, but contained in source files without the need for separate
   INCLUDE files or error-prone repetition of the declarations.

       $SET varname  string

   If a $SET or $IMPORT directive defines a name prep(1) enters expansion mode.
   In this mode anywhere the string "${NAME}" is encountered in subsequent
   output it is replaced by "string".

   o values are case-sensitive but variable names are not.
   o expansion of a line may cause it to be longer than allowed by some
     compilers. Automatic breaking into continuation lines does not occur.
   o comments are not supported on a $SET directive because everything past the
     variable name becomes part of the value.
   o The pre-defined values $FILE, $LINE, $DATE, and $TIME ( for input file,
     line in input file, date and time ) are NOT ACTIVE until at least one
     one $SET or $IMPORT directive is processed. That is, unless a variable
     is defined no ${NAME} expansion occurs.
   o The time and date refers to the time of processing, not the time of
     compilation or loading.

   Example:

    > $set author  William Shakespeare
    > write(*,*)'By ${AUTHOR}'
    > write(*,*)'File ${FILE}'
    > write(*,*)'Line ${LINE}'
    > write(*,*)'Date ${DATE}'
    > write(*,*)'Time ${TIME}'
   ...

       $IMPORT   envname[;...]                              [! comment ]

   The values of environment variables may be imported just like their names
   and values were used on a $SET directive. The names of the variables are
   case-sensitive in regards to obtaining the values, but the names become
   case-insensitive in prep(). That is, "import home" gets the lowercase
   environment variable "home" and then sets the associated value for the
   variable "HOME" to the value.

    > $import HOME USER
    > write(*,*)'HOME ${HOME}'
    > write(*,*)'USER ${USER}'

 EXTERNAL FILES
   Directives for reading and writing external files ...

       $OUTPUT   filename  [--append]                          [! comment ]
       $INCLUDE filename

   Details ...

       $OUTPUT   filename  [--append]                          [! comment ]

   Specifies the output file to write to. This overrides the initial output file
   specified with command line options. If no output filename is given
   prep(1) reverts back to the initial output file. "@" is a synonym for stdout.

   Files are open at the first line by default. Use the --append switch to
   append to the end of an existing file instead of overwriting it.

       $INCLUDE filename

   Read in the specified input file. Fifty (50) nesting levels are allowed.
   Following the tradition of cpp(1) if "<filename>" is specified the file is
   only searched for relative to the search directories, otherwise it is
   searched for as specified first. Double-quotes in the filename are treated
   as in Fortran list-directed input.

 TEXT BLOCK FILTERS
   (--file is ignored unless $PREP_DOCUMENT_DIR is set)

      $BLOCK   [null|comment|write|variable [--varname NAME]|
               set|system|message|define
               help|version] [--file NAME [--append]]      [! comment ]
      $ENDBLOCK                                            [! comment ]

   Details ...

   $BLOCK has several forms but in all cases operates on a block of lines:

     basic filtering:
      $BLOCK [comment|null|write                 [--file NAME [--append]]
     creating a CHARACTER array:
      $BLOCK VARIABLE --varname NAME             [--file NAME [--append]]
     block versions of prep(1) commands:
      $BLOCK set|system|message|define           [--file NAME [--append]]
     specialized procedure construction:
      $BLOCK help|version                        [--file NAME [--append]]

      NULL:      Do not write into current output file
      COMMENT:   write text prefixed by an exclamation and a space or according
                 to the style selected by the --comment style selected on the
                 command line.
      WRITE:     write text as Fortran WRITE(3f) statements
                 The Fortran generated is free-format. It is assumed the
                 output will not generate lines over 132 columns.
      VARIABLE:  write as a text variable. The name may be defined using
                 the --varname switch. Default name is "textblock".
      MESSAGE:   All the lines in the block are treated as options to $MESSAGE
      SET:       All the lines in the block are treated as options to $SET
      DEFINE:    All the lines in the block are treated as options to $DEFINE
      SYSTEM:    The lines are gathered into a file and executed by the shell
                 with the stdout being written to a scratch file and then read
      END:       End block of specially processed text

   special-purpose modes primarily for use with the M_kracken module:

      HELP:      write text as a subroutine called HELP_USAGE
      VERSION:   write text as a subroutine called HELP_VERSION prefixing
                 lines with @(#) for use with the what(1) command.

   If the "--file NAME" option is present the text is written to the
   specified file unfiltered except for string expansion. This allows
   documentation to easily be maintained in the source file. It can be
   tex, html, markdown or any plain text. The filename will be prefixed
   with $PREP_DOCUMENT_DIR/doc/ . If the environment variable
   $PREP_DOCUMENT_DIR is not set the option is ignored.

   The --file output can subsequently easily be processed by other utilities
   such as markdown(1) or txt2man(1) to produce man(1) pages and HTML documents.
   $SYSTEM commands may follow the $BLOCK block text to optionally post-process
   the doc files.

   $ENDBLOCK ends the block.

 IDENTIFIERS
   Directives for producing metadata ...

       $IDENT|$@(#) metadata [--language fortran|c|shell]      [! comment ]

   $IDENT is a special-purpose directive useful to users of SCCS-metadata.
   The string generated can be used by the what(1) command,

   When the command line option "--ident [LANGUAGE]" is specified this directive
   writes a line using SCCS-metadata format of one of the following forms:

     language:
     fortran   character(len=*),parameter::ident="@(#)metadata"
     c         #ident "@(#)metadata"
     shell     #@(#) metadata

   The default language is "fortran".

   Depending on your compiler and the optimization level used when compiling,
   the output string may not remain in the object files and executables created.

   If the -ident switch is not specified, a Fortran comment line is generated
   of the form

       ! ident_NNN="@(#)this is metadata"

   "$@(#)" is an alias for "$IDENT" so the source file itself will contain
   SCCS-metadata so the metadata can be displayed with what(1) even for the
   unprocessed files.

   Do not use the characters double-quote, greater-than, backslash (ie. ">\)
   in the metadata to remain compatible with SCCS metadata syntax.
   Do not use strings starting with " -" either.

 INFORMATION
   Informative directives for writing messages to stderr or inserting
   state information into the output file ...

       $SHOW [variable_name[;...]]                          [! comment ]
       $MESSAGE  message_to_stderr

   Details ...

       $MESSAGE  message_to_stderr

   Write message to stderr.
   Note that messages for $MESSAGE do not treat "! " as starting a comment

       $SHOW [variable_name[;...]]                          [! comment ]

   Shows current state of prep(1); including variable names and values and
   the name of the current input files. All output is preceded by an
   exclamation character.

   If a list of defined variable names is present only those variables and
   their values are shown.

   Basic globbing is supported, where "*" represents any string, and "?"
   represents any single character.

   Example:

    > prep A=10 B C D -o paper
    > $define z=22
    > $show B Z
    > $show
    > $show H*;*H;*H*! show beginning with "H", ending with "H", containing "H"
    > $stop 0
    >
    > !  B  =  1
    > !  Z  =  22
    > !================================================================
    > !
    > ! Current state of prep(1):(18:39 20 Jun 2021)
    > ! Total lines read ............... 2
    > ! Conditional nesting level....... 0
    > ! G_WRITE (general processing).... T
    > ! G_LLWRITE (write input lines)... T
    > ! Arguments ...................... A=10 B C D -o paper
    > ! Open files:
    > !    unit ! line number ! filename
    > !       5 !           2 ! @
    > ! INCLUDE directories:
    > !    .
    > ! Variables:
    > !    $DEFINE UNKNOWN  =  0
    > !    $DEFINE LINUX  =  1
    > !    $DEFINE MACOS  =  2
    > !    $DEFINE WINDOWS  =  3
    > !    $DEFINE CYGWIN  =  4
    > !    $DEFINE SOLARIS  =  5
    > !    $DEFINE FREEBSD  =  6
    > !    $DEFINE OPENBSD  =  7
    > !    $DEFINE OS  =  1
    > !    $DEFINE A  =  10
    > !    $DEFINE B  =  1
    > !    $DEFINE C  =  1
    > !    $DEFINE D  =  1
    > !    $DEFINE Z  =  22
    > ! Parcels:
    > !================================================================

 SYSTEM COMMANDS
   Directives that execute system commands ...

       $SYSTEM system_command

   If system command processing is enabled using the --system switch system
   commands can be executed for such tasks as creating files to be read or to
   further process documents created by $BLOCK. $SYSTEM directives are errors
   by default; as you clearly need to ensure the input file is trusted before
   before allowing commands to be executed. Commands that are system-specific
   may need to be executed conditionally as well.

   Examples:

    > $! build variable definitions using GNU/Linux commands
    > $SYSTEM echo system=`hostname` > compiled.h
    > $SYSTEM echo compile_time="`date`" >> compiled.h
    > $INCLUDE compiled.h

    > $if systemon      ! if --system switch is present on command line
    > $!  obtain up-to-date copy of source file from HTTP server:
    > $   SYSTEM wget http://repository.net/src/func.F90 -O - >_tmp.f90
    > $   INCLUDE _tmp.f90
    > $   SYSTEM  rm _tmp.f90
    > $endif

   System commands may also appear in a $BLOCK section. Combining several
   features this uses the Linux getconf(1) command to write some lines
   into a scratch file that are then read back in to define variables describing
   the current platform.

    > $IF OS == LINUX
    > $
    > $block system ! use getconf(1) command to get system values
    > (
    > echo LEVEL_2_CACHE_SIZE $(getconf LEVEL2_CACHE_SIZE)
    > echo LEVEL_3_CACHE_SIZE $(getconf LEVEL3_CACHE_SIZE)
    > ) >_getconf.inc
    > $endblock
    > $block set                 ! read in output of getconf(1)
    > $include _getconf.inc
    > $endblock
    > $system rm -f _getconf.inc ! cleanup
    > $
    > $ELSE
    > $
    > $error " ERROR: Not Linux. did not obtain system values"
    > $
    > $ENDIF
    > $! create code using values for this platform
    >    integer, parameter :: L2_CACHE_SZ=${LEVEL2_CACHE_SIZE}
    >    integer, parameter :: L3_CACHE_SZ=${LEVEL3_CACHE_SIZE}

 PROGRAM TERMINATION
   Directives for stopping file processing (note there is no comment field):

      $STOP     [stop_value ["message"]]
      $QUIT     ["message"]
      $ERROR    ["message"]

   Details ...

      $STOP     [stop_value ["message"]]

   Stops the prep(1) program. The integer value will be returned as an exit
   status value by the system where supported.

   o A value of "0" causes normal program termination.
   o The default value is "1".
   o comments are not supported on these directives; the entire line following
     the directive command becomes part of the message.
   o If a message is supplied it is displayed to stderr.
     If the value is not zero ("0") and no message is supplied the "$SHOW"
     directive is called before stopping.
   o "$QUIT" is an alias for "$STOP 0".
   o "$ERROR" is a synonym for "$STOP 1"

     >$IFNDEF TYPE
     >$STOP 10 "ERROR: ""TYPE"" not defined"
     >$ENDIF

LIMITATIONS

   $IF constructs can be nested up to 20 levels deep. Note that using
   more than two levels typically makes input files less readable.

   $ENDBLOCK is required after a $BLOCK or --file FILENAME is not written.

   Nesting of $BLOCK sections not allowed.
   $INCLUDE may be nested fifty (50) levels.

   Input files

   o lines are limited to a maximum of 1024 columns. Text past the limit is
     ignored.
   o files cannot be concurrently opened multiple times
   o a maximum of 50 files can be nested by $INCLUDE
   o filenames cannot contain spaces on the command line.

   Variable names

   o are limited to 63 characters.
   o must start with a letter (A-Z) or underscore(_).
   o are composed of the letters A-Z, digits 0-9 and _ and $.
   o 2048 variable names may be defined at a time.

EXAMPLES

  Define variables on command line:

  Typically, variables are defined on the command line when prep(1) is
  invoked but can be grouped together into small files that are included
  with a $INCLUDE or as input files.

    > prep HP size=64 -i hp_directives.dirs test.F90 -o test_out.f90

  defines variables HP and SIZE as if the expressions had been on a
  $DEFINE and reads file "hp_directives.dirs" and then test.F90.
  Output is directed to test_out.f90

  Basic conditionals:

   > $! set variable "a" if not specified on the prep(1) command.
   > $IF .NOT.DEFINED(A)
   > $   DEFINE a=1  ! so only define the first version of SUB(3f) below
   > $ENDIF
   >    program conditional_compile
   >       call sub()
   >    end program conditional_compile
   > $! select a version of SUB depending on the value of variable "a"
   > $IF a .EQ. 1
   >    subroutine sub
   >       print*, "This is the first SUB"
   >    end subroutine sub
   > $ELSEIF a .eq. 2
   >    subroutine sub
   >       print*, "This is the second SUB"
   >    end subroutine sub
   > $ELSE
   >    subroutine sub
   >       print*, "This is the third SUB"
   >    end subroutine sub
   > $ENDIF

  Common use of $BLOCK

   > $!
   > $BLOCK NULL --file manual.tex
   > This is a block of text that will be ignored except it is optionally
   > written to a $PREP_DOCUMENT_DIR/doc/ file when $PREP_DOCUMENT_DIR is set.
   > $ENDBLOCK
   >

  This is a block of text that will be converted to comments and optionally
  appended to a $PREP_DOCUMENT_DIR/doc/ file when $PREP_DOCUMENT_DIR is set.

   > $BLOCK COMMENT--file conditional_compile.man
   > NAME
   >    conditional_compile - basic example for prep(1) preprocessor.
   > SYNOPSIS
   >    conditional_example [--help] [--version]
   > DESCRIPTION
   >    This is a basic example program showing how documentation can be
   >    used to generate program help text
   > OPTIONS
   >    --help     display this help and exit
   >    --version  output version information and exit
   > $ENDBLOCK

GENERAL TEMPLATING
  A parcel can be posted multiple times, changing the value of variables
  before each post.

   > $PARCEL mysub
   > subroutine mysub_${TYPE}(a,b)
   > use, intrinsic :: iso_fortran_env, only : &
   > & real_kinds, real32,real64,real128
   > implicit none
   > integer,parameter  :: wp=${TYPE}
   > real(kind=wp) :: a,b
   >    write(*,*)10.0_wp
   >    write(*,*) "this is for type ${TYPE}"
   > end subroutine mysub_${TYPE}
   >
   > $ENDPARCEL
   > $set type real32
   > $post mysub
   > $set type real64
   > $post mysub
   > $set type real128
   > $post mysub

NOTE
  Not documented elsewhere, note that there is a developer flag (--debug) that
  can be useful when learning prep(1) usage (but it should not be used in
  production). Among other things it deactivates the termination of the program
  upon detection of an error. This mode thus allows for simple interactive use.
  In addition, when in this mode entering "$HELP" produces a cribsheet, which
  may also be displayed by "prep --crib".
AUTHOR
   John S. Urban

LICENSE
   MIT

